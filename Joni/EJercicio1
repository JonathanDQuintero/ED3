/*https://bow-bike-fd5.notion.site/Segundo-parcial-Pr-ctico-12325f3f13c680d6b196eedd68c7e021
**EJERCICIO Nº 1: (30 %)**

*Programar el microcontrolador LPC1769 para que mediante su ADC digitalice  dos señales analógicas
*cuyos anchos de bandas son de 10 Khz cada una. Los canales utilizados deben ser el 2 y el 4 y los 
*datos deben ser guardados en dos regiones de memorias distintas que permitan contar con los 
*últimos 20 datos de cada canal. 
*Suponer una frecuencia de core cclk de 100 Mhz. El código debe estar debidamente comentado.
*/
#include "LPC17xx.h"
#include "LPC17xx_adc.h"
#include "LPC17xx_pinsel.h"

#define OUTPUT     (uint8_t) 1
#define INPUT      (uint8_t) 0

#define PIN_25    ((uint32_t)(1<<25)) // pin 25 del puerto 0 AD0.2
#define PIN_30    ((uint32_t)(1<<30)) // pin 30 del puerto 1 AD0.4

#define INT_CH2        ADC_ADINTEN2  // interrupcion por cada conversion canal 2
#define INT_CH4        ADC_ADINTEN4  // interrupcion por cada conversion canal 4
#define CH2      ADC_CHANNEL_2 // canal 2 del ADC (AD0.2 P0.25)
#define CH4      ADC_CHANNEL_4 // canal 4 del ADC (AD0.4 P1.30)

#define BUFFER_SIZE 20
#define Clk_FREQ 100000000 // Frecuencia del core en Hz
#define SAMPLE_RATE 40000 // Frecuencia de muestreo en Hz (20kHz por canal) por teorema de Nyquist tiene que ser el doble de la banda en cada canal

_IO uint32_t adc_value_ch2[BUFFER_SIZE]; // buffer circular para canal 2
_IO uint32_t adc_value_ch4[BUFFER_SIZE]; // buffer circular para canal 4
uint32_t index_ch2 = 0; // índice para buffer canal 2
uint32_t index_ch4 = 0; // índice para buffer canal 4

void confADC(void);
void ADC_IRQHandler(void);
void confPin(void);

int main(void){
    confADC();//configuro el ADC
    confPin();//configuro los pines del ADC
    while(1){
        __WFI(); // Espera a la interrupción para ahorrar energía 
            //el muestreo se maneja por hardware, no es necesario hacer nada en el loop principal
    }
}
void confPin(void){
    PINSEL_CFG_Type PinCfg;
    PinCfg.Portnum = PINSEL_PORT_1;
    PinCfg.Pinnum = PINSEL_PIN_25; // P0.25 AD0.2
    PinCfg.Pinmode = PINSEL_TRISTATE;// sin pull-up ni pull-down
    PinCfg.OpenDrain = PINSEL_OD_NORMAL;
    PinCfg.Funcnum = PINSEL_FUNC_1;

    PINSEL_ConfigPin(&PinCfg);
    GPIO_SetDir(PINSEL_PORT_1,PIN_25,INPUT);//configuro el pin como salida
    
    PinCfg.Portnum = PINSEL_PORT_3;
    PinCfg.Pinnum = PINSEL_PIN_30; // P1.30 AD0.4   
    PinCfg.Funcnum = PINSEL_FUNC_3;

    PINSEL_ConfigPin(&PinCfg);
    GPIO_SetDir(PINSEL_PORT_3,PIN_30,INPUT)//configuro el pin como salida
}
void confADC(void){
    ADC_Init(LPC_ADC,2600000);//inicializo el ADC a 2.6MHZ para que me de una frecuencia de muestreo de 40kHz
    ADC_IntConfig(LPC_ADC,INT_CH2|INT_CH4,ENABLE);//habilito la interrupcion por cada conversion de los canales 2 y 4
    ADC_ChannelCmd(LPC_ADC,CH2|CH4,ENABLE);//habilito el canal 2 y 4 del ADC
    
    NVIC_SetPriority(ADC_IRQn,(9));// seteo la priorida de la interrupcion del ADC como 9
    NVIC_EnableIRQ(ADC_IRQn);//habilito las interrupciones del ADC
    ADC_BurstCmd(LPC_ADC,ENABLE);//habilito el modo burst para que el ADC funcione de forma continua

    return;
}
void ADC_IRQHandler(void){
    adc_value_ch2[index_ch2] =0;
    adc_value_ch4[index_ch4] =0;
    if(ADC_ChannelGetStatus(LPC_ADC,CH2,ADC_DATA_DONE))
    {
        adc_value_ch2[index_ch2] = ADC_ChannelGetData(LPC_ADC,CH2); // leo el valor convertido del canal 2 y lo guardo en el buffer
        index_ch2 = (index_ch2 + 1) % BUFFER_SIZE; // actualizo el índice circular para canal 2
    }
    if(ADC_ChannelGetStatus(LPC_ADC,CH4,ADC_DATA_DONE)){
        adc_value_ch4[index_ch4] = ADC_ChannelGetData(LPC_ADC,CH4); // leo el valor convertido del canal 4 y lo guardo en el buffer
        index_ch4 = (index_ch4 + 1) % BUFFER_SIZE; // actualizo el índice circular para canal 4

    }
}
/***EJERCICIO Nº2: (45 %)**
*
*Utilizando el timer0, un dac, interrupciones y el driver del LPC1769 , escribir un código que permita 
*generar una señal triangular periódica simétrica, que tenga el mínimo periodo posible, la máxima excursión
*de voltaje pico a pico posible y el mínimo incremento de señal posible por el dac. Suponer una frecuencia
*de core cclk de 100 Mhz. El código debe estar debidamente comentado.
*
*/
#include "lpc17xx_adc.h"
#include "lpc17xx_dac.h"
#include "lpc17xx_pinsel.h" 
#include "lpc17xx_timer.h"
#include "lpc17xx_gpdma.h"

#define INPUT      (uint8_t) 0
#define OUTPUT     (uint8_t) 1

#define PIN_26  ((uint32_t)(1<<26))// P0.26 DAC salida analogica
#define NUM_WAVE_SAMPLES 2046 // cantidad de muestras de la senoidal para maximo incremento posible del DAC

#define CLK_FREQ 100000000 // Frecuencia del core en Hz
#define DAC_MAX_VALUE 1023 // Valor máximo del DAC (10 bits)
_IO uint32_t WaveFormInit[NUM_WAVE_SAMPLES]; // array que contiene la forma de onda a generar
void configDAC(void);
void configTimer(void);
void configPin(void);
void confDMA(void);
void confWave(void);
int main(void){
    configPin();
    configDAC();
    configTimer();
    confWave();
    confDMA();  
    while(1){
    }
}
void configPin(void){
    PINSEL_CFG_Type PinCfg;
    PinCfg.PortNum = PINSEL_PORT_0;
    PinCfg.PinNum = PINSEL_PIN_26;
    PinCfg.PinMode = PINSEL_TRISTATE;
    PinCfg.funcNum = PINSEL_FUNC_2;
    PinCfg.openDrain = PINSEL_OD_NORMAL;
    PINSEL_ConfigPin(&PinCfg);
    GPIO_SetDir(PINSEL_PORT_0,PIN_26,OUTPUT);//configuro el pin como salida
    return;

}
void configDAC(void){

    DAC_CONVERTER_CFG_Type DAC_Configstruct;
    DAC_Configstruct. DAC_CNT_ENA = ENABLE;
    DAC_Configstruct. DAC_DMA_ENA = ENABLE;
    DAC_Configstruct. DAC_BIAS_EN = DISABLE;
    DAC_Init(LPC_DAC);
    DAC_ConfigDAConverterControl(LPC_DAC, &DAC_Configstruct);
    return;
}
void configTimer(void){
    TIM_TIMERCFG_Type struct_config;
    TIM_MATCHCFG_Type struct_match;
    struct_config.PrescalerOption = TIM_PRESCALE_USVAL; // valor del prescaler en microsegundos
    strcut_config.PrecaleValue = 1; // cada 1us se incrementa el timer
    TIM_Init(LPC_TIM0, TIM_TIMER_MODE, &struct_config);
    struct_match.matchChannel = TIM_MATCH_CHANNEL_0;
    struct_match.intOnMatch = ENABLE; // habilito la interrupcion en el match
    struct_match.resteOnMatch = ENABLE; // reseteo el timer en el match
    struct_match.stopOnMatch = DISABLE; // no detengo el timer en el match
    struct_match.extMatchOutputType = TIM_NOTHING; // no hago nada con la salida externa en el match
    struct_match.matchValue = 1; // cada 1us hago un match
    TIM_ConfigMatch(LPC_TIM0, &struct_match);  
    NVIC_EnableIRQ(TIMER0_IRQn); // habilito las interrupciones del timer0
    TIM_Cmd(LPC_TIM0, ENABLE); // habilito el timer0
}
void confDMA(void){
    GPDMA_LLI_Type DMA_LLI_struct;
    DMA_LLI_struct.srcAddr = (uint32_t)&WaveFormInit;// direccion de origen (array de la forma de onda)
    DMA_LLI_struct.dstAddr = (uint32_t)&LPC_DAC->DACR; // direccion de destino (registro del DAC)
    DMA_LLI_strcut.nextLLI= (uint32_t)&DMA_LLI_struct;// direccion de la siguiente LLI (circular)
    DMA_LLI_strcut.control = NUM_WAVE_SAMPLES
                            |(2<<18)// ancho de burst de la fuente de 32 bits
                            |(2<<21)//ancho de burst de destino de 32 bits
                            |(1<<26)//incremento en la fuente
                            ;
    GPDMA_Init();
    GPDMA_Channel_CFG_Type DMA_Channel_config;
    DMA_Channel_config.channelNum = 0;
    DMA_Channel_config.transferSize = NUM_WAVE_SAMPLES;
    DMA_Channel_config.transferWidth = 0;//solo se usa para M2M por lo que no es necesario
    DMA_Channel_config.srcMemAddr = (uint32_t)&WaveFormInit;//direccion de origen
    DMA_Channel_config.dstMemAddr = 0;//por que el destino es periferico
    DMA_Channel_config.transferType = GPDMA_TRANSFERTYPE_M2P;//de memoria a periferico
    DMA_Channel_config.srcConn = 0;// no es periferico
    DMA_Channel_config.dstConn = GPDMA_CONN_DAC;//conexion al DAC
    DMA_Channel_config.linkedList = (uint32_t)&DMA_LLI_struct;//direccion de la LLI
    GDMA_Setup(&DMA_Channel_config);
    GPDMA_ChannelCmd(0,ENABLE);//habilito el canal 0 del DMA
    return;
}
void confWave(void){
    uint32_t WaveFormInit[NUM_WAVE_SAMPLES];
   
    for(uint16_t i=0; i<NUM_WAVE_SAMPLES; i++){
        if(i<(WavaFormInit/4)){
            WaveformInit[i]=512+(512*i)/(NUM_WAVE_SAMPLES/4);

        }else if(i<WaveFormInit/2){
            WaveformInit[i]=1023-512*(i-(NUM_WAVE_SAMPLES/4))/(NUM_WAVE_SAMPLES/4);
        }else if(i/3*NUM_WAVE_SAMPLES/4){
            WaveformInit[i]=512-512*(i-((NUM_WAVE_SAMPLES/2)))/(NUM_WAVE_SAMPLES/4);
        }else if(i<NUM_WAVE_SAMPLES){
            WaveFormInit[i]=(512*(i-3*NUM_WAVE_SAMPLES/4)/(NUM_WAVE_SAMPLES/4));

        }
        WaveFormInit[i]=WaveFormInit[i]<<6;
        return;


        }}